<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 08 Apr 2017 15:02:36 +0800</pubDate>
    <lastBuildDate>Sat, 08 Apr 2017 15:02:36 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>String常量池的深入理解</title>
        <description>&lt;h2 id=&quot;1-常量池概念&quot;&gt;1. 常量池概念&lt;/h2&gt;

&lt;h3 id=&quot;11-常量池&quot;&gt;&lt;strong&gt;1.1 常量池&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了关于类，方法，接口等中的常量，也包括字符串常量，如String s = “java”这种申明方式；当然也可扩充，执行器产生的常量也会放入常量池，故认为常量池是JVM的一块特殊的内存空间
   &lt;a href=&quot;http://baike.baidu.com/link?url=lX6ZWhY7GLm06XdFfUzKbVxgIf-2sLgOo8t9-OCapARUC2As3V7yOEJQJOjZKag-kMkyBReNf--Gl0jxHKQwH-AmPk7Ce9my8U_ELJWMPfHVU3-aVCoCk5l79KAJLwpq&quot;&gt;百度百科&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-string类和常量池&quot;&gt;2. String类和常量池&lt;/h2&gt;
&lt;h3 id=&quot;21-string的-和-equals&quot;&gt;2.1 String的”==” 和 “equals()”&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;==&lt;/strong&gt; 由于String是引用类型,只有指向同一个对象时，才会==判断为true。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;equals()&lt;/strong&gt; String已经重写了Object的equals()方法，只要两个字符串所包含的字符序列相同就会返回true。
    &lt;h3 id=&quot;22-string对象创建方式&quot;&gt;2.2 String对象创建方式&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;产生一个字符串对象
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;{
  //编译时即可计算出字符串值，JVM在常量池创建字符串对象，管理&quot;abc&quot;
  String s1 = &quot;abc&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;产生两个字符串对象
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;{
  //JVM会先使用常量池创建管理字符串对象，再调用String类构造器来创建一个新的String对象。
  String s2 = new String(&quot;abc&quot;);
    
  System.out.println(s1 == s2);//输出false
  System.out.println(s1.equals(s2));//输出true
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;h3 id=&quot;23-连接表达式-&quot;&gt;2.3 连接表达式 “+”&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;字符串&lt;strong&gt;直接量&lt;/strong&gt;使String对象之间使用”+”连接产生的新对象才会被加入字符串池中。(区分关键是编译时是否能确认出直接量的值)
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;{
  String s1 = &quot;a&quot;;
  String s2 = &quot;bc&quot;;
  String s3 = &quot;abc&quot;;
        
  //编译时可以确定，可以引用常量池中字符串
  String s4 = &quot;a&quot;+&quot;b&quot;+&quot;c&quot;;
  //编译时无法确定，不能引用常量池中字符串
  String s5 = s1+s2;
  String s6 = new String(&quot;abc&quot;);
        
  System.out.println(s3 == s4);//true
  System.out.println(s3 == s5);//false
  System.out.println(s3 == s6);//false
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;h3 id=&quot;24-intern&quot;&gt;2.4 intern()&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;java.lang.String.intern() 方法返回一个字符串对象的规范表示。当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（该对象由 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。&lt;/li&gt;
  &lt;li&gt;它遵循对于任何两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;{
    String str1 = &quot;a&quot;;
    String str2 = &quot;b&quot;;
    String str3 = &quot;ab&quot;;

    String str4 = str1 + str2;//常量池中已经存在，直接取出
    String str5 = &quot;a&quot; + &quot;b&quot;;

    System.out.println(str3 == str4); // false
    System.out.println(str3 == str4.intern()); // true
    System.out.println(str3 == str5);// true
}
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Wed, 11 Jan 2017 13:31:01 +0800</pubDate>
        <link>http://localhost:4000/2017/01/11/Java-String%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/11/Java-String%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</guid>
        
        <category>Java基础</category>
        
        
        <category>Java</category>
        
      </item>
    
      <item>
        <title>Java包装类解读</title>
        <description>&lt;h2 id=&quot;1基本类型和包装类对应关系&quot;&gt;1.基本类型和包装类对应关系&lt;/h2&gt;

&lt;p&gt;除了int和char例外，其他均首字母大写
基本数据类型 | 包装类
—|—
byte|Byte 
short|Short
int|Integer 
long|Long
char|Charater
float|Float
double|Double
boolean|Bloolean&lt;/p&gt;
&lt;h2 id=&quot;2基本类型和包装类转换&quot;&gt;2.基本类型和包装类转换&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;自动装箱和拆箱
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;自动装箱：&lt;/strong&gt; 基本类型–&amp;gt;包装类&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  {
      //1.直接把基本变量赋值给Integer对象
      Integer intObj = 5;
      //2.直接把基本变量赋值给Object对象
      Object boolObject = true;
  }
  
&lt;/code&gt;&lt;/pre&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;自动拆箱：&lt;/strong&gt; 基本类型&amp;lt;–包装类
```Java
{
    //1.直接把Integer赋值给int
    int it = intObj;&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;//2.先把Object强制转换成Boolean，再赋值给boolean
if (boolObject instanceof Boolean){
    boolean b = (Boolean)boolObject;
} }
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;```&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 自动拆箱和装箱只能在对应类型之间，例如int和Integer。&lt;/p&gt;
    &lt;h2 id=&quot;3包装类和字符串直接转换&quot;&gt;3.包装类和字符串直接转换&lt;/h2&gt;
  &lt;/li&gt;
  &lt;li&gt;字符串转化成基本类型
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  {
      String intStr = &quot;111&quot;;
        
      //1.利用包装类提供的Xxx(String x)构造器
      int int1 = new Integer(intStr);
        
      //2.利用包装类提供的parseXxx(String x)静态方法
      int int2 = Integer.parseInt(intStr);
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; Character包装类无此parseXxx(String x)静态方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;基本类型转化成字符串
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  {
      int it1 = 111;
        
      //1.通过String.valueOf(xxx)转换
      String str1 = String.valueOf(int1);
        
      //2.将基本变量和&quot;&quot;进行连接运算
      String str2 = it1 + &quot;&quot;;
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4包装类基本变量相互比较&quot;&gt;4.包装类，基本变量相互比较&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;包装类和基本变量比较&lt;/p&gt;

    &lt;p&gt;可以直接进行数值比较&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  {
      Integer a = new Integer(100);
      //输出true
      System.out.println(&quot;100的包装类实力是否大于50:&quot;+(a &amp;gt; 50));
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;包装类直接相互比较&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;包装类实例实际是引用类型，只有两个包装类引用同一个对象时才会返回true
        &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;{
    //输出false
    System.out.println(&quot;比较100的包装类是否相等:&quot;+
    (new Integer(100) == new Integer(100)));
}
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;特殊情况(部分面试会问）：应用常量池的场景&lt;/strong&gt; 自动装箱可以把一些基本类型赋值给一个包装类实例，但会有以下特殊情况~&lt;/p&gt;

        &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public static void main(String[] args)
{
    //Java在编译的时候会直接将代码封装成Intege从而使用常量池中的对象
    Integer ina = 2;
    Integer inb = 2;
    System.out.println(&quot;两个2自动装箱后是否相等&quot;+ (ina == inb)); // 输出true
			
    //超出缓存数组范围，无法使用常量池
    Integer biga = 128;
    Integer bigb = 128;
    System.out.println(&quot;两个2自动装箱后是否相等&quot;+ (biga == bigb)); // 输出false
}
&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;&lt;strong&gt;直接看源码分析：&lt;/strong&gt;
系统会把一个-128~127之间的数值自动装箱成Integer实例，并放入cache数组缓存起来，如果以后还有这个范围的整数自动装箱，实际上是指向同一个数组元素，但不在这个范围内的，系统会重新创建一个Integer实例。&lt;/p&gt;

        &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // high value may be configured by property
        int h = 127;
        String integerCacheHighPropValue =
            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);
        if (integerCacheHighPropValue != null) {
            try {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            } catch( NumberFormatException nfe) {
                // If the property cannot be parsed into an int, ignore it.
            }
        }
        high = h;

        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k &amp;lt; cache.length; k++)
            cache[k] = new Integer(j++);

        // range [-128, 127] must be interned (JLS7 5.1.7)
        assert IntegerCache.high &amp;gt;= 127;
    }

    private IntegerCache() {}
}
    
public static Integer valueOf(int i) {
    if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}

&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;同上，也使用cache的如下面列表所示：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;包装类&lt;/th&gt;
      &lt;th&gt;缓存数组范围&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Byte&lt;/td&gt;
      &lt;td&gt;static final Byte cache[] = new Byte[-(-128) + 127 + 1];&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Short&lt;/td&gt;
      &lt;td&gt;static final Short cache[] = new Short[-(-128) + 127 + 1]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Long&lt;/td&gt;
      &lt;td&gt;static final Long cache[] = new Long[-(-128) + 127 + 1];&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Character&lt;/td&gt;
      &lt;td&gt;static final Character cache[] = new Character[127 + 1];&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Float&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Double&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Boolean&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;创建新的对象
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   {
    i1 = 40;
    //创建新的对象
    Integer i2 = new Integer(40);
    System.out.println(i1==i2);//输出false
   }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;综合举例
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   {
  public static void main(String[] args) {
   int i0 = 127;
   Integer i1 = 127;
   Integer i2 = 127;
   Integer i3 = 0;
   Integer i4 = new Integer(127);
   Integer i5 = new Integer(127);
   Integer i6 = new Integer(0);

   System.out.println(&quot;i0=i1   &quot;  +(i0==i1));//true
   System.out.println(&quot;i0=i4   &quot;  +(i0==i4));//true

   System.out.println(&quot;i1=i2   &quot; + (i1 == i2));//true
   System.out.println(&quot;i1=i2+i3   &quot; + (i1 == i2 + i3));//true
   System.out.println(&quot;i1=i4   &quot; + (i1 == i4));//false

   System.out.println(&quot;i4=i5   &quot; + (i4 == i5));//false
   System.out.println(&quot;i4=i5+i6   &quot; + (i4 == i5 + i6));//true
   System.out.println(&quot;127=i5+i6   &quot; + (127 == i5 + i6));//true
   System.out.println(&quot;---------------------------&quot;);

   int i20 = 128;
   Integer i21 = 128;
   Integer i22 = 128;
   Integer i23 = 0;
   Integer i24 = new Integer(128);
   Integer i25 = new Integer(128);
   Integer i26 = new Integer(0);

   System.out.println(&quot;i20=i21   &quot;  +(i20==i21));//true
   System.out.println(&quot;i20=i24   &quot;  +(i20==i24));//true

   System.out.println(&quot;i21=i22   &quot; + (i21 == i22));//!!!!!!false
   System.out.println(&quot;i21=i22+i23   &quot; + (i21 == i22 + i23));//true
   System.out.println(&quot;i21=i24   &quot; + (i21 == i24));//false

   System.out.println(&quot;i24=i25   &quot; + (i24 == i25));//false
   System.out.println(&quot;i24=i25+i26   &quot; + (i24 == i25 + i26));//true
   System.out.println(&quot;128=i25+i26   &quot; + (128 == i25 + i26));//true
    }
   }
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;int和其他Integer进行==比较是会自动拆箱为int类型。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ol&gt;
      &lt;li&gt;语句i4 == i5 +i6，因为+这个操作符不适用于Integer对象，是进行数值运算，要首先分别对i5和i6进行自动拆箱操作，进行数值相加，即i4 == 127。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值127，最终这条语句转为127 == 127进行数值比较。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 17 Dec 2016 13:31:01 +0800</pubDate>
        <link>http://localhost:4000/2016/12/17/Java%E5%8C%85%E8%A3%85%E7%B1%BB%E8%A7%A3%E8%AF%BB/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/12/17/Java%E5%8C%85%E8%A3%85%E7%B1%BB%E8%A7%A3%E8%AF%BB/</guid>
        
        <category>Java基础</category>
        
        
        <category>Java</category>
        
      </item>
    
  </channel>
</rss>
