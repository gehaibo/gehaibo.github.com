<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>Stay hungry, stay foolish.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 15 May 2017 21:51:44 +0800</pubDate>
    <lastBuildDate>Mon, 15 May 2017 21:51:44 +0800</lastBuildDate>
    <generator>Jekyll v3.4.3</generator>
    
      <item>
        <title>插入类排序</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#1直接插入排序&quot; id=&quot;markdown-toc-1直接插入排序&quot;&gt;1.直接插入排序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2折半插入排序&quot; id=&quot;markdown-toc-2折半插入排序&quot;&gt;2.折半插入排序&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3希尔排序&quot; id=&quot;markdown-toc-3希尔排序&quot;&gt;3.希尔排序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1直接插入排序&quot;&gt;1.直接插入排序&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;从第二个元素开始，将后面无序序列中的各元素依次插入到已经有序的线性表中&lt;/li&gt;
  &lt;li&gt;稳定排序&lt;/li&gt;
  &lt;li&gt;最好：n（基本有序）,最坏：n^2, 平均：n^2，空间复杂度1
    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static void insertSort(int[] a) {
      if(a == null || a.length &amp;lt;= 1){
          return;
      }
      for (int i = 1; i &amp;lt; a.length; i++) {
          int temp = a[i];//位置可能被覆盖掉
          int pos = i - 1;//前面排好的最末尾

          while (pos &amp;gt;= 0 &amp;amp;&amp;amp; temp &amp;lt; a[pos]) {
              a[pos + 1] = a[pos];//后移一位
              pos--;
          }
          a[pos + 1] = temp;//temp找到插入位置
      }
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;2折半插入排序&quot;&gt;2.折半插入排序&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;从第二个元素开始，将后面无序序列中的各元素依次插入到已经有序的线性表中，插入的时候采用折半查找。&lt;/li&gt;
  &lt;li&gt;稳定排序&lt;/li&gt;
  &lt;li&gt;最好：n（基本有序）,最坏：n^2, 平均：n^2，空间复杂度1&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static void binaryInsertSort(int[] a) {
        if(a == null || a.length &amp;lt;= 1){
            return;
        }
        for (int i = 1; i &amp;lt; a.length; i++) {

            int temp = a[i];
            //根据折半查找找到要插入的最低位置low
            int low = 0;
            int high = i - 1;
            while (low &amp;lt;= high) {
                int mid = (low + high) / 2;
                if (temp &amp;lt; a[mid]) high = mid - 1;
                else low = mid + 1;
            }

            //low后元素全部后移，再将temp插入
            for (int j = i; j &amp;gt; low; j--) {
                a[j] = a[j - 1];
            }
            a[low] = temp;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;3希尔排序&quot;&gt;3.希尔排序&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;将整个无序序列分割成若干小的子序列分别进行插入排序&lt;/li&gt;
  &lt;li&gt;不稳定排序&lt;/li&gt;
  &lt;li&gt;最好：n（基本有序）,最坏：n^2,平均：nlog2n，空间复杂度1
    &lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public static void shellSort(int[] a){
      int d=a.length/2;//增量
      while (d&amp;gt;=1){//增量几次，每轮需要遍历几次
          for (int i = 0; i &amp;lt; d; i++) {
              //下面就是插入排序，从下一个开始，间隔是d
              for (int j = i+d; j &amp;lt; a.length; j=j+d) {
                  int temp = a[j];
                  int pos = j - d;
                  while (pos &amp;gt;= 0 &amp;amp;&amp;amp; a[pos] &amp;gt; temp) {
                      a[pos + d] = a[pos];
                      pos -= d;
                  }
                  a[pos + d] = temp;
              }
          }
          d=d/2;
      }
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 11 Apr 2017 10:31:01 +0800</pubDate>
        <link>http://localhost:4000/2017/04/11/%E6%8F%92-%E5%85%A5-%E7%B1%BB-%E6%8E%92-%E5%BA%8F/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/04/11/%E6%8F%92-%E5%85%A5-%E7%B1%BB-%E6%8E%92-%E5%BA%8F/</guid>
        
        <category>排序</category>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>Java泛型</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#1基本类型和包装类对应关系&quot; id=&quot;markdown-toc-1基本类型和包装类对应关系&quot;&gt;1.基本类型和包装类对应关系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1基本类型和包装类对应关系&quot;&gt;1.基本类型和包装类对应关系&lt;/h1&gt;
</description>
        <pubDate>Sun, 05 Feb 2017 16:31:01 +0800</pubDate>
        <link>http://localhost:4000/2017/02/05/java-Generic/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/02/05/java-Generic/</guid>
        
        <category>Java语法糖</category>
        
        
        <category>Java基础</category>
        
      </item>
    
      <item>
        <title>String常量池的深入理解</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#1常量池概念&quot; id=&quot;markdown-toc-1常量池概念&quot;&gt;1.常量池概念&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#11-常量池&quot; id=&quot;markdown-toc-11-常量池&quot;&gt;1.1 常量池&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2string类和常量池&quot; id=&quot;markdown-toc-2string类和常量池&quot;&gt;2.String类和常量池&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#21-string的-和-equals&quot; id=&quot;markdown-toc-21-string的-和-equals&quot;&gt;2.1 String的”==” 和 “equals()”&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#22-string对象创建方式&quot; id=&quot;markdown-toc-22-string对象创建方式&quot;&gt;2.2 String对象创建方式&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1常量池概念&quot;&gt;1.常量池概念&lt;/h1&gt;

&lt;h2 id=&quot;11-常量池&quot;&gt;1.1 常量池&lt;/h2&gt;

&lt;p&gt;在java用于保存在编译期已确定的，已编译的class文件中的一份数据。它包括了关于类，方法，接口等中的常量，也包括字符串常量，如String s = “java”这种申明方式；当然也可扩充，执行器产生的常量也会放入常量池，故认为常量池是JVM的一块特殊的内存空间
&lt;a href=&quot;http://baike.baidu.com/link?url=lX6ZWhY7GLm06XdFfUzKbVxgIf-2sLgOo8t9-OCapARUC2As3V7yOEJQJOjZKag-kMkyBReNf--Gl0jxHKQwH-AmPk7Ce9my8U_ELJWMPfHVU3-aVCoCk5l79KAJLwpq&quot;&gt;百度百科&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;2string类和常量池&quot;&gt;2.String类和常量池&lt;/h1&gt;

&lt;h2 id=&quot;21-string的-和-equals&quot;&gt;2.1 String的”==” 和 “equals()”&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;==&lt;/strong&gt; 由于String是引用类型,只有指向同一个对象时，才会==判断为true。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;equals()&lt;/strong&gt; String已经重写了Object的equals()方法，只要两个字符串所包含的字符序列相同就会返回true。
    &lt;h3 id=&quot;22-string对象创建方式&quot;&gt;2.2 String对象创建方式&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;产生一个字符串对象
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;{
  //编译时即可计算出字符串值，JVM在常量池创建字符串对象，管理&quot;abc&quot;
  String s1 = &quot;abc&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;产生两个字符串对象
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;{
  //JVM会先使用常量池创建管理字符串对象，再调用String类构造器来创建一个新的String对象。
  String s2 = new String(&quot;abc&quot;);

  System.out.println(s1 == s2);//输出false
  System.out.println(s1.equals(s2));//输出true
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;2.3 连接表达式 “+”
———————————-&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;字符串&lt;strong&gt;直接量&lt;/strong&gt;使String对象之间使用”+”连接产生的新对象才会被加入字符串池中。(区分关键是编译时是否能确认出直接量的值)
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;{
  String s1 = &quot;a&quot;;
  String s2 = &quot;bc&quot;;
  String s3 = &quot;abc&quot;;

  //编译时可以确定，可以引用常量池中字符串
  String s4 = &quot;a&quot;+&quot;b&quot;+&quot;c&quot;;
  //编译时无法确定，不能引用常量池中字符串
  String s5 = s1+s2;
  String s6 = new String(&quot;abc&quot;);

  System.out.println(s3 == s4);//true
  System.out.println(s3 == s5);//false
  System.out.println(s3 == s6);//false
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;2.4 intern()
———————————-&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;java.lang.String.intern() 方法返回一个字符串对象的规范表示。当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（该对象由 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并且返回此 String 对象的引用。&lt;/li&gt;
  &lt;li&gt;它遵循对于任何两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;{
    String str1 = &quot;a&quot;;
    String str2 = &quot;b&quot;;
    String str3 = &quot;ab&quot;;

    String str4 = str1 + str2;//常量池中已经存在，直接取出
    String str5 = &quot;a&quot; + &quot;b&quot;;

    System.out.println(str3 == str4); // false
    System.out.println(str3 == str4.intern()); // true
    System.out.println(str3 == str5);// true
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 11 Jan 2017 13:31:01 +0800</pubDate>
        <link>http://localhost:4000/2017/01/11/Java-Constant-pool/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/11/Java-Constant-pool/</guid>
        
        <category>Java语法糖</category>
        
        
        <category>Java基础</category>
        
      </item>
    
      <item>
        <title>Zookeeper学习笔记之(一) - Zookeeper基本介绍</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#简介&quot; id=&quot;markdown-toc-简介&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#基本概念&quot; id=&quot;markdown-toc-基本概念&quot;&gt;基本概念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#设计目的&quot; id=&quot;markdown-toc-设计目的&quot;&gt;设计目的&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#基本概念-1&quot; id=&quot;markdown-toc-基本概念-1&quot;&gt;基本概念&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#集群角色&quot; id=&quot;markdown-toc-集群角色&quot;&gt;集群角色&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#会话&quot; id=&quot;markdown-toc-会话&quot;&gt;会话&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#数据节点&quot; id=&quot;markdown-toc-数据节点&quot;&gt;数据节点&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#版本&quot; id=&quot;markdown-toc-版本&quot;&gt;版本&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#watcher&quot; id=&quot;markdown-toc-watcher&quot;&gt;Watcher&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#acl&quot; id=&quot;markdown-toc-acl&quot;&gt;ACL&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#数据模型&quot; id=&quot;markdown-toc-数据模型&quot;&gt;数据模型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考资料&quot; id=&quot;markdown-toc-参考资料&quot;&gt;参考资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;声明：本文大部分内容均摘录自参考资料。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;简介&quot;&gt;简介&lt;/h1&gt;

&lt;p&gt;ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户。&lt;/p&gt;

&lt;p&gt;在分布式应用中，由于工程师不能很好地使用锁机制，以及基于消息的协调机制不适合在某些应用中使用，因此需要有一种可靠的、可扩展的、分布式的、可配置的协调机制来统一系统的状态。Zookeeper的目的就在于此。&lt;/p&gt;

&lt;h1 id=&quot;基本概念&quot;&gt;基本概念&lt;/h1&gt;

&lt;h1 id=&quot;设计目的&quot;&gt;设计目的&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/zookeeper/01-introduction/01-zkservice.jpg&quot; alt=&quot;/images/blog/zookeeper/01-introduction/01-zkservice.jpg&quot; /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Sequential Consistency&lt;/td&gt;
      &lt;td&gt;Updates from a client will be applied in the order that they were sent.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Atomicity&lt;/td&gt;
      &lt;td&gt;Updates either succeed or fail. No partial results.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Single System Image&lt;/td&gt;
      &lt;td&gt;A client will see the same view of the service regardless of the server that it connects to.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Reliability&lt;/td&gt;
      &lt;td&gt;Once an update has been applied, it will persist from that time forward until a client overwrites the update.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Timeliness&lt;/td&gt;
      &lt;td&gt;The clients view of the system is guaranteed to be up-to-date within a certain time bound.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;基本概念-1&quot;&gt;基本概念&lt;/h1&gt;

&lt;h2 id=&quot;集群角色&quot;&gt;集群角色&lt;/h2&gt;

&lt;p&gt;通常在分布式系统中，构成一个集群的每一台机器都有自己的角色，最典型的集群模式就是Master/Slave模式(主备模式)。在这种模式中，我们把能够处理所有写操作的机器成为Master机器，把所有通过异步复制方式获取最新数据，并提供读服务的机器成为Slave机器。&lt;/p&gt;

&lt;p&gt;而在Zookeeper中，这些概念被颠覆了。它没有沿用传统的Master/Slave概念，而是引入了Leader,Follower和Observer三种角色。Zookeeper集群中的所有机器通过一个Leader选举过程来选定一台被称为Leader的机器，Leader服务器为客户端提供读和写服务。除Leader外，其它机器包括Follower和Observer。Follower和Observer都能提供读服务，唯一的区别在于，Observer机器不参与Leader选举过程，也不参与写操作的“过半写成功”策略，因此Observer可以在不影响写性能的情况下提升集群的读性能。&lt;/p&gt;

&lt;h2 id=&quot;会话&quot;&gt;会话&lt;/h2&gt;

&lt;p&gt;Session是指客户端会话。在讲会话之前，首先了解下客户端连接。在Zookeeper中，一个客户端连接是指客户端和服务器之间的一个TCP长连接。Zookeeper对外的服务器端口默认是2181，客户端启动的时候，首先会与服务器建立一个TCP连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接收响应，同时还能够通过该连接接收来自服务器的Watch事件通知。Session的sessionTimeout值用来设置一个客户端会话的超时时间。当由于服务器压力太大，网络故障或是客户端主动断开链接等各种原因导致客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。&lt;/p&gt;

&lt;h2 id=&quot;数据节点&quot;&gt;数据节点&lt;/h2&gt;

&lt;p&gt;在谈到分布式的时候，通常所说的“节点”是指组成集群的每一台机器。然而，在Zookeeper中，“节点”分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点-ZNode。Zookeeper将所有数据存储在内存中，数据模型是一棵树(ZNode Tree),由斜杠(/)进行分割的路径，就是一个ZNode，例如/foo/path1。每个ZNode上都会保存自己的数据内容，同时还会保存一系列属性信息。&lt;/p&gt;

&lt;p&gt;在Zookeeper中，ZNode可以分为持久节点和临时节点两类。所谓持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在Zookeeper上。而临时节点就不一样了，它的生命周期和客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。另外，Zookeeper还允许用户为每个节点添加一个特殊的属性：SEQUENTIAL。一旦节点被标记上这个属性，那么在这个节点被创建的时候，Zookeeper会自动在其节点名后面追加上一个整型数字，这个整型数字是一个由父节点维护的自增数字。&lt;/p&gt;

&lt;h2 id=&quot;版本&quot;&gt;版本&lt;/h2&gt;

&lt;p&gt;Zookeeper的每个ZNode上都会存储数据，对应于每个ZNode，Zookeeper都会为其维护一个叫做Stat的数据结构，Stat中记录了这个ZNode的三个数据版本，分别是version(当前ZNode的版本)，cversion(当前ZNode子节点的版本)和aversion(当前ZNode的ACL版本)。&lt;/p&gt;

&lt;h2 id=&quot;watcher&quot;&gt;Watcher&lt;/h2&gt;

&lt;p&gt;Watcher(事件监听器)，是Zookeeper中的一个很重要的特性。Zookeeper允许用户在制定节点上注册一些Watcher，并且在一些特定事件触发的时候，Zookeeper服务端会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的重要特性。&lt;/p&gt;

&lt;h2 id=&quot;acl&quot;&gt;ACL&lt;/h2&gt;

&lt;p&gt;Zookeeper采用ACL(Access Control Lists)策略来进行权限控制，类似于Unix文件系统的权限控制。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CREATE：创建子节点的权限&lt;/li&gt;
  &lt;li&gt;READ：获取节点数据和子节点列表的权限&lt;/li&gt;
  &lt;li&gt;WRITE：更新节点数据的权限&lt;/li&gt;
  &lt;li&gt;DELETE：删除子节点的权限&lt;/li&gt;
  &lt;li&gt;ADMIN：设置节点ACL权限&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;尤其需要注意的是，CREATE和DELETE这两种权限都是针对子节点的权限控制。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;数据模型&quot;&gt;数据模型&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/zookeeper/01-introduction/02-zknamespace.jpg&quot; alt=&quot;/images/blog/zookeeper/01-introduction/02-zknamespace.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Zookeeper提供的命名空间类似于文件系统。每个目录项如 NameService 都被称作为znode，和文件系统一样，我们能够自由的增加、删除znode，在一个znode下增加、删除子znode，唯一的不同在于znode是可以存储数据的。ZNode根据持久化和序列化分为4种&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;PERSISTENT&lt;/td&gt;
      &lt;td&gt;持久化目录节点。客户端与zookeeper断开连接后，该节点依旧存在&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PERSISTENT_SEQUENTIAL&lt;/td&gt;
      &lt;td&gt;持久化顺序编号目录节点。客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EPHEMERAL&lt;/td&gt;
      &lt;td&gt;临时目录节点。客户端与zookeeper断开连接后，该节点被删除&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EPHEMERAL_SEQUENTIAL&lt;/td&gt;
      &lt;td&gt;临时顺序编号目录节点。客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;参考资料&quot;&gt;参考资料&lt;/h1&gt;

&lt;p&gt;百度百科：&lt;a href=&quot;http://baike.baidu.com/link?url=OB8b21xw3UldXVI0ghTO_cpEEw0BbjDlVtUJb4BoVpuCh7t6VmDP2MCxxt36KI4TK2ZzJ3a0oxkIrK5ozovm6h6F6UqDvu5CN7wanmGc-5W&quot;&gt;zookeeper&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Zookeeper官方文档：&lt;a href=&quot;http://zookeeper.apache.org/doc/trunk/zookeeperOver.html&quot;&gt;http://zookeeper.apache.org/doc/trunk/zookeeperOver.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;zookeeper原理（转） : &lt;a href=&quot;http://cailin.iteye.com/blog/2014486/&quot;&gt;http://cailin.iteye.com/blog/2014486/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Zookeeper的功能以及工作原理 : &lt;a href=&quot;http://www.cnblogs.com/felixzh/p/5869212.html&quot;&gt;http://www.cnblogs.com/felixzh/p/5869212.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;《从PAXOS到ZOOKEEPER分布式一致性原理与实践》 - 倪超&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Jan 2017 14:02:00 +0800</pubDate>
        <link>http://localhost:4000/2017/01/04/zookeeper-01-introduction/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/01/04/zookeeper-01-introduction/</guid>
        
        <category>zookeeper</category>
        
        
        <category>技术文档</category>
        
      </item>
    
      <item>
        <title>Java包装类解读</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#1基本类型和包装类对应关系&quot; id=&quot;markdown-toc-1基本类型和包装类对应关系&quot;&gt;1.基本类型和包装类对应关系&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2基本类型和包装类转换&quot; id=&quot;markdown-toc-2基本类型和包装类转换&quot;&gt;2.基本类型和包装类转换&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3包装类和字符串直接转换&quot; id=&quot;markdown-toc-3包装类和字符串直接转换&quot;&gt;3.包装类和字符串直接转换&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4包装类基本变量相互比较&quot; id=&quot;markdown-toc-4包装类基本变量相互比较&quot;&gt;4.包装类，基本变量相互比较&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1基本类型和包装类对应关系&quot;&gt;1.基本类型和包装类对应关系&lt;/h1&gt;

&lt;p&gt;除了int和char例外，其他均首字母大写
基本数据类型 | 包装类
—|—
byte|Byte
short|Short
int|Integer
long|Long
char|Charater
float|Float
double|Double
boolean|Bloolean&lt;/p&gt;

&lt;h1 id=&quot;2基本类型和包装类转换&quot;&gt;2.基本类型和包装类转换&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;自动装箱和拆箱&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;自动装箱：&lt;/strong&gt; 基本类型–&amp;gt;包装类&lt;/p&gt;

    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;  {
      //1.直接把基本变量赋值给Integer对象
      Integer intObj = 5;
      //2.直接把基本变量赋值给Object对象
      Object boolObject = true;
  }

&lt;/code&gt;&lt;/pre&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;自动拆箱：&lt;/strong&gt; 基本类型&amp;lt;–包装类
```Java
{
    //1.直接把Integer赋值给int
    int it = intObj;&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;//2.先把Object强制转换成Boolean，再赋值给boolean
if (boolObject instanceof Boolean){
    boolean b = (Boolean)boolObject;
} }
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;```&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; 自动拆箱和装箱只能在对应类型之间，例如int和Integer。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3包装类和字符串直接转换&quot;&gt;3.包装类和字符串直接转换&lt;/h1&gt;

&lt;p&gt;字符串转化成基本类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    {
        String intStr = &quot;111&quot;;

        //1.利用包装类提供的Xxx(String x)构造器
        int int1 = new Integer(intStr);

        //2.利用包装类提供的parseXxx(String x)静态方法
        int int2 = Integer.parseInt(intStr);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt; Character包装类无此parseXxx(String x)静态方法&lt;/p&gt;

&lt;p&gt;基本类型转化成字符串&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    {
        int it1 = 111;

        //1.通过String.valueOf(xxx)转换
        String str1 = String.valueOf(int1);

        //2.将基本变量和&quot;&quot;进行连接运算
        String str2 = it1 + &quot;&quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;4包装类基本变量相互比较&quot;&gt;4.包装类，基本变量相互比较&lt;/h1&gt;

&lt;p&gt;包装类和基本变量比较，可以直接进行数值比较&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    {
        Integer a = new Integer(100);
        //输出true
        System.out.println(&quot;100的包装类实力是否大于50:&quot;+(a &amp;gt; 50));
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;包装类直接相互比较&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;包装类实例实际是引用类型，只有两个包装类引用同一个对象时才会返回true
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;{
    //输出false
    System.out.println(&quot;比较100的包装类是否相等:&quot;+
    (new Integer(100) == new Integer(100)));
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;&lt;strong&gt;特殊情况(部分面试会问）：应用常量池的场景&lt;/strong&gt; 自动装箱可以把一些基本类型赋值给一个包装类实例，但会有以下特殊情况~&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public static void main(String[] args)
{
    //Java在编译的时候会直接将代码封装成Intege从而使用常量池中的对象
    Integer ina = 2;
    Integer inb = 2;
    System.out.println(&quot;两个2自动装箱后是否相等&quot;+ (ina == inb)); // 输出true

    //超出缓存数组范围，无法使用常量池
    Integer biga = 128;
    Integer bigb = 128;
    System.out.println(&quot;两个2自动装箱后是否相等&quot;+ (biga == bigb)); // 输出false
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;&lt;strong&gt;直接看源码分析：&lt;/strong&gt;
系统会把一个-128~127之间的数值自动装箱成Integer实例，并放入cache数组缓存起来，如果以后还有这个范围的整数自动装箱，实际上是指向同一个数组元素，但不在这个范围内的，系统会重新创建一个Integer实例。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;    private static class IntegerCache {
        static final int low = -128;
        static final int high;
        static final Integer cache[];

        static {
            // high value may be configured by property
            int h = 127;
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);
            if (integerCacheHighPropValue != null) {
                try {
                    int i = parseInt(integerCacheHighPropValue);
                    i = Math.max(i, 127);
                    // Maximum array size is Integer.MAX_VALUE
                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                } catch( NumberFormatException nfe) {
                    // If the property cannot be parsed into an int, ignore it.
                }
            }
            high = h;

            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k &amp;lt; cache.length; k++)
                cache[k] = new Integer(j++);

            // range [-128, 127] must be interned (JLS7 5.1.7)
            assert IntegerCache.high &amp;gt;= 127;
        }

        private IntegerCache() {}
    }

    public static Integer valueOf(int i) {
        if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;同上，也使用cache的如下面列表所示：&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;包装类&lt;/th&gt;
      &lt;th&gt;缓存数组范围&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Byte&lt;/td&gt;
      &lt;td&gt;static final Byte cache[] = new Byte[-(-128) + 127 + 1];&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Short&lt;/td&gt;
      &lt;td&gt;static final Short cache[] = new Short[-(-128) + 127 + 1]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Long&lt;/td&gt;
      &lt;td&gt;static final Long cache[] = new Long[-(-128) + 127 + 1];&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Character&lt;/td&gt;
      &lt;td&gt;static final Character cache[] = new Character[127 + 1];&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Float&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Double&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Boolean&lt;/td&gt;
      &lt;td&gt;无&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;创建新的对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   {
        i1 = 40;
        //创建新的对象
        Integer i2 = new Integer(40);
        System.out.println(i1==i2);//输出false
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;综合举例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;   {
       public static void main(String[] args) {
        int i0 = 127;
        Integer i1 = 127;
        Integer i2 = 127;
        Integer i3 = 0;
        Integer i4 = new Integer(127);
        Integer i5 = new Integer(127);
        Integer i6 = new Integer(0);

        System.out.println(&quot;i0=i1   &quot;  +(i0==i1));//true
        System.out.println(&quot;i0=i4   &quot;  +(i0==i4));//true

        System.out.println(&quot;i1=i2   &quot; + (i1 == i2));//true
        System.out.println(&quot;i1=i2+i3   &quot; + (i1 == i2 + i3));//true
        System.out.println(&quot;i1=i4   &quot; + (i1 == i4));//false

        System.out.println(&quot;i4=i5   &quot; + (i4 == i5));//false
        System.out.println(&quot;i4=i5+i6   &quot; + (i4 == i5 + i6));//true
        System.out.println(&quot;127=i5+i6   &quot; + (127 == i5 + i6));//true
        System.out.println(&quot;---------------------------&quot;);

        int i20 = 128;
        Integer i21 = 128;
        Integer i22 = 128;
        Integer i23 = 0;
        Integer i24 = new Integer(128);
        Integer i25 = new Integer(128);
        Integer i26 = new Integer(0);

        System.out.println(&quot;i20=i21   &quot;  +(i20==i21));//true
        System.out.println(&quot;i20=i24   &quot;  +(i20==i24));//true

        System.out.println(&quot;i21=i22   &quot; + (i21 == i22));//!!!!!!false
        System.out.println(&quot;i21=i22+i23   &quot; + (i21 == i22 + i23));//true
        System.out.println(&quot;i21=i24   &quot; + (i21 == i24));//false

        System.out.println(&quot;i24=i25   &quot; + (i24 == i25));//false
        System.out.println(&quot;i24=i25+i26   &quot; + (i24 == i25 + i26));//true
        System.out.println(&quot;128=i25+i26   &quot; + (128 == i25 + i26));//true
    }
   }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;int和其他Integer进行==比较是会自动拆箱为int类型。&lt;/li&gt;
  &lt;li&gt;语句i4 == i5 +i6，因为+这个操作符不适用于Integer对象，是进行数值运算，要首先分别对i5和i6进行自动拆箱操作，进行数值相加，即i4 == 127。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值127，最终这条语句转为127 == 127进行数值比较。&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 17 Nov 2016 12:31:01 +0800</pubDate>
        <link>http://localhost:4000/2016/11/17/Java-Packaging-class/</link>
        <guid isPermaLink="true">http://localhost:4000/2016/11/17/Java-Packaging-class/</guid>
        
        <category>Java语法糖</category>
        
        
        <category>Java基础</category>
        
      </item>
    
      <item>
        <title>Welcome to Jekyll!</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#诫子书&quot; id=&quot;markdown-toc-诫子书&quot;&gt;诫子书&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First POST build by Jekyll.&lt;/p&gt;

&lt;h2 id=&quot;诫子书&quot;&gt;诫子书&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/styles/images/jiezishu.jpg&quot; alt=&quot;诫子书&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;诸葛亮&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;夫君子之行，静以修身，俭以养德。非淡泊(澹泊)无以明志，非宁静无以致远。夫学须静也，才须学也。非学无以广才，非志无以成学。淫慢则不能励精，险躁则不能冶性。
年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及！&lt;/p&gt;

</description>
        <pubDate>Mon, 17 Nov 2014 13:31:01 +0800</pubDate>
        <link>http://localhost:4000/2014/11/17/welcome-to-jekyll/</link>
        <guid isPermaLink="true">http://localhost:4000/2014/11/17/welcome-to-jekyll/</guid>
        
        <category>jekyll</category>
        
        
        <category>jekyll</category>
        
      </item>
    
  </channel>
</rss>
